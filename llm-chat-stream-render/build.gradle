buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath 'com.guardsquare:proguard-gradle:7.4.0'
        classpath 'org.ow2.asm:asm:9.7.1'
        classpath 'org.ow2.asm:asm-tree:9.7.1'
    }
}

import groovy.json.JsonSlurper

plugins {
    id 'java'
    id 'org.jetbrains.intellij' version '1.15.0'
}

configurations {
    proguard
}


group = 'cn.lacknb.blog'
version = '1.0.1'

java {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
}

intellij {
    version.set("2022.2")
    plugins = ['java']
    updateSinceUntilBuild = false
    downloadSources = false
}

tasks {
    patchPluginXml {
        changeNotes = """
        Initial version of the plugin
        """
        sinceBuild = '222'
//        untilBuild = '222.*'
    }
}

tasks.buildPlugin {
    dependsOn("obfuscateJar")

    // --- 核心修复：更强力的排除逻辑 ---
    exclude { details ->
        // 1. 只检查 lib 目录下的文件
        if (!details.path.startsWith("lib/")) {
            return false
        }

        def name = details.file.name
        // 2. 只要文件名包含项目名，且是以 .jar 结尾，一律踢掉！
        // 这样既能杀掉 "llm-chat-stream-render-1.0.1.jar"
        // 也能杀掉 "instrumented-llm-chat-stream-render-1.0.1.jar"
        // (前提是你的混淆 jar 名字不要和这些撞车，我们下面会重命名)
        if (name.contains(project.name) && name.endsWith(".jar")) {
            return true // 返回 true 表示排除该文件
        }

        return false
    }
    // --- 放入混淆后的 Jar ---
    from("$buildDir/obfuscated/${project.name}-obf.jar") {
        into("lib")
        // 重命名为最标准的名字：项目名-版本号.jar
        // 这样 IDEA 加载时最干净
        rename { "${project.name}-${project.version}.jar" }
    }
}

dependencies {
    implementation 'com.google.code.gson:gson:2.10.1'
    implementation 'org.commonmark:commonmark:0.22.0'
    testImplementation platform('org.junit:junit-bom:5.9.1')
    testImplementation 'org.junit.jupiter:junit-jupiter'
}

def embeddedConfigOutputDir = file("$buildDir/generated/sources/llmConfig/java")
def embeddedConfigFile = project.findProperty("llmConfigFile") ?
        file(project.property("llmConfigFile")) :
        rootProject.file(".llm-chat-stream-render.json")

sourceSets {
    main {
        java {
            srcDir embeddedConfigOutputDir
        }
    }
}

tasks.register('generateEmbeddedLlmConfig') {
    inputs.file(embeddedConfigFile).optional()
    outputs.dir(embeddedConfigOutputDir)
    doLast {
        embeddedConfigOutputDir.mkdirs()
        def outputFile = new File(embeddedConfigOutputDir, "cn/lacknb/blog/llm/stream/EmbeddedLLMConfig.java")
        outputFile.parentFile.mkdirs()

        def configPresent = embeddedConfigFile.exists()
        def parsed = configPresent ? new JsonSlurper().parse(embeddedConfigFile) : [:]
        def baseUrl = parsed?.baseUrl
        def apiKey = parsed?.apiKey
        def model = parsed?.model

        def secureRandom = new java.security.SecureRandom()
        def keyBytes = new byte[16]
        secureRandom.nextBytes(keyBytes)

        def encrypt = { String value, byte[] key, byte[] iv ->
            if (value == null || value.isBlank()) {
                return null
            }
            def cipher = javax.crypto.Cipher.getInstance("AES/GCM/NoPadding")
            def keySpec = new javax.crypto.spec.SecretKeySpec(key, "AES")
            def gcmSpec = new javax.crypto.spec.GCMParameterSpec(128, iv)
            cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, keySpec, gcmSpec)
            return cipher.doFinal(value.getBytes("UTF-8"))
        }

        def toByteArrayLiteral = { byte[] bytes ->
            if (bytes == null) {
                return "null"
            }
            if (bytes.length == 0) {
                return "new byte[0]"
            }
            def sb = new StringBuilder("new byte[] {")
            for (int i = 0; i < bytes.length; i++) {
                if (i > 0) {
                    sb.append(", ")
                }
                sb.append("(byte) ").append(bytes[i])
            }
            sb.append("}")
            return sb.toString()
        }

        def genIv = {
            def iv = new byte[12]
            secureRandom.nextBytes(iv)
            return iv
        }

        def baseUrlIv = baseUrl != null ? genIv() : null
        def apiKeyIv = apiKey != null ? genIv() : null
        def modelIv = model != null ? genIv() : null

        def baseUrlEnc = baseUrlIv != null ? encrypt(baseUrl, keyBytes, baseUrlIv) : null
        def apiKeyEnc = apiKeyIv != null ? encrypt(apiKey, keyBytes, apiKeyIv) : null
        def modelEnc = modelIv != null ? encrypt(model, keyBytes, modelIv) : null

        def keyLiteral = toByteArrayLiteral(keyBytes)
        def baseUrlIvLiteral = toByteArrayLiteral(baseUrlIv)
        def apiKeyIvLiteral = toByteArrayLiteral(apiKeyIv)
        def modelIvLiteral = toByteArrayLiteral(modelIv)
        def baseUrlEncLiteral = toByteArrayLiteral(baseUrlEnc)
        def apiKeyEncLiteral = toByteArrayLiteral(apiKeyEnc)
        def modelEncLiteral = toByteArrayLiteral(modelEnc)

        outputFile.text = """
package cn.lacknb.blog.llm.stream;

final class EmbeddedLLMConfig {
    private static final boolean PRESENT = ${configPresent};
    private static final byte[] KEY = ${keyLiteral};
    private static final byte[] BASE_URL_IV = ${baseUrlIvLiteral};
    private static final byte[] API_KEY_IV = ${apiKeyIvLiteral};
    private static final byte[] MODEL_IV = ${modelIvLiteral};
    private static final byte[] BASE_URL_DATA = ${baseUrlEncLiteral};
    private static final byte[] API_KEY_DATA = ${apiKeyEncLiteral};
    private static final byte[] MODEL_DATA = ${modelEncLiteral};

    private EmbeddedLLMConfig() {
    }

    static LLMConfig load() {
        if (!PRESENT) {
            return null;
        }
        return new LLMConfig(
                d(BASE_URL_DATA, BASE_URL_IV),
                d(API_KEY_DATA, API_KEY_IV),
                d(MODEL_DATA, MODEL_IV)
        );
    }

    private static String d(byte[] data, byte[] iv) {
        if (data == null || data.length == 0 || iv == null || iv.length == 0) {
            return null;
        }
        return AesUtil.decryptToString(data, KEY, iv);
    }
}
""".stripIndent()
    }
}

tasks.named('compileJava') {
    dependsOn(tasks.named('generateEmbeddedLlmConfig'))
}

def stringCryptoOutputDir = file("$buildDir/generated/sources/stringCrypto/java")
def stringCryptoKeyFile = file("$buildDir/string-crypto/key.bin")
def encryptedClassesDir = file("$buildDir/encrypted-classes")

ext.stringEncryptConfig = [
        enabled: true,
        includePackages: ['cn.lacknb.blog.llm.stream'],
        includeAnnotations: ['cn.lacknb.blog.llm.stream.EncryptStrings'],
        excludeAnnotations: ['cn.lacknb.blog.llm.stream.NoStringEncrypt'],
        excludeClasses: [
                'cn.lacknb.blog.llm.stream.AesUtil',
                'cn.lacknb.blog.llm.stream.StringDecryptor',
                'cn.lacknb.blog.llm.stream.EmbeddedLLMConfig',
                'cn.lacknb.blog.llm.stream.EncryptStrings',
                'cn.lacknb.blog.llm.stream.NoStringEncrypt'
        ]
]

sourceSets {
    main {
        java {
            srcDir stringCryptoOutputDir
        }
    }
}

tasks.register('generateStringDecryptor') {
    outputs.dir(stringCryptoOutputDir)
    outputs.file(stringCryptoKeyFile)
    doLast {
        stringCryptoOutputDir.mkdirs()
        stringCryptoKeyFile.parentFile.mkdirs()

        def keyBytes = new byte[16]
        new java.security.SecureRandom().nextBytes(keyBytes)
        stringCryptoKeyFile.bytes = keyBytes

        def keyLiteral = keyBytes.collect { "(byte) ${it}" }.join(", ")
        def outputFile = new File(stringCryptoOutputDir, "cn/lacknb/blog/llm/stream/StringDecryptor.java")
        outputFile.parentFile.mkdirs()
        outputFile.text = """
package cn.lacknb.blog.llm.stream;

final class StringDecryptor {
    private static final byte[] KEY = new byte[] { ${keyLiteral} };

    private StringDecryptor() {
    }

    static String d(byte[] data, byte[] iv) {
        return AesUtil.decryptToString(data, KEY, iv);
    }
}
""".stripIndent()
    }
}

tasks.named('compileJava') {
    dependsOn(tasks.named('generateStringDecryptor'))
}

tasks.register('encryptStrings') {
    dependsOn(tasks.named('compileJava'), tasks.named('processResources'))
    inputs.dir(file("$buildDir/classes/java/main"))
    inputs.file(stringCryptoKeyFile)
    outputs.dir(encryptedClassesDir)
    doLast {
        if (!stringEncryptConfig.enabled) {
            println "String encryption disabled."
            return
        }
        if (!stringCryptoKeyFile.exists()) {
            throw new GradleException("Missing string crypto key: ${stringCryptoKeyFile}")
        }
        def keyBytes = stringCryptoKeyFile.bytes
        if (keyBytes == null || keyBytes.length == 0) {
            throw new GradleException("Empty string crypto key: ${stringCryptoKeyFile}")
        }

        project.delete(encryptedClassesDir)
        project.copy {
            from("$buildDir/classes/java/main")
            into(encryptedClassesDir)
        }
        project.copy {
            from("$buildDir/resources/main")
            into(encryptedClassesDir)
        }

        def includePackages = (stringEncryptConfig.includePackages ?: []).collect { it.replace('.', '/') }
        def includeAnnDesc = (stringEncryptConfig.includeAnnotations ?: []).collect {
            "L" + it.replace('.', '/') + ";"
        } as Set
        def excludeAnnDesc = (stringEncryptConfig.excludeAnnotations ?: []).collect {
            "L" + it.replace('.', '/') + ";"
        } as Set
        def excludeClasses = (stringEncryptConfig.excludeClasses ?: []).collect { it.replace('.', '/') } as Set

        def hasAnnotation = { List annotations, Set targets ->
            if (annotations == null || annotations.isEmpty() || targets.isEmpty()) {
                return false
            }
            return annotations.any { targets.contains(it.desc) }
        }

        def classInPackages = { String className ->
            if (includePackages.isEmpty()) {
                return false
            }
            return includePackages.any { className == it || className.startsWith(it + "/") }
        }

        def shouldEncryptClass = { ClassNode cn ->
            if (excludeClasses.contains(cn.name)) {
                return false
            }
            boolean inPkg = classInPackages(cn.name)
            boolean annotated = hasAnnotation(cn.visibleAnnotations, includeAnnDesc) ||
                    hasAnnotation(cn.invisibleAnnotations, includeAnnDesc)
            boolean excluded = hasAnnotation(cn.visibleAnnotations, excludeAnnDesc) ||
                    hasAnnotation(cn.invisibleAnnotations, excludeAnnDesc)
            return !excluded && (inPkg || annotated)
        }

        def shouldEncryptField = { FieldNode fn, boolean classEncrypt ->
            boolean excluded = hasAnnotation(fn.visibleAnnotations, excludeAnnDesc) ||
                    hasAnnotation(fn.invisibleAnnotations, excludeAnnDesc)
            if (excluded) {
                return false
            }
            if (classEncrypt) {
                return true
            }
            boolean annotated = hasAnnotation(fn.visibleAnnotations, includeAnnDesc) ||
                    hasAnnotation(fn.invisibleAnnotations, includeAnnDesc)
            return annotated
        }

        def shouldEncryptMethod = { MethodNode mn, boolean classEncrypt ->
            boolean excluded = hasAnnotation(mn.visibleAnnotations, excludeAnnDesc) ||
                    hasAnnotation(mn.invisibleAnnotations, excludeAnnDesc)
            if (excluded) {
                return false
            }
            if (classEncrypt) {
                return true
            }
            boolean annotated = hasAnnotation(mn.visibleAnnotations, includeAnnDesc) ||
                    hasAnnotation(mn.invisibleAnnotations, includeAnnDesc)
            return annotated
        }

        def pushInt = { InsnList insnList, int value ->
            if (value >= -1 && value <= 5) {
                insnList.add(new InsnNode(Opcodes.ICONST_0 + value))
            } else if (value >= -128 && value <= 127) {
                insnList.add(new IntInsnNode(Opcodes.BIPUSH, value))
            } else if (value >= -32768 && value <= 32767) {
                insnList.add(new IntInsnNode(Opcodes.SIPUSH, value))
            } else {
                insnList.add(new LdcInsnNode(value))
            }
        }

        def buildByteArray = { byte[] bytes ->
            InsnList insnList = new InsnList()
            if (bytes == null) {
                insnList.add(new InsnNode(Opcodes.ACONST_NULL))
                return insnList
            }
            pushInt(insnList, bytes.length)
            insnList.add(new IntInsnNode(Opcodes.NEWARRAY, Opcodes.T_BYTE))
            for (int i = 0; i < bytes.length; i++) {
                insnList.add(new InsnNode(Opcodes.DUP))
                pushInt(insnList, i)
                pushInt(insnList, bytes[i])
                insnList.add(new InsnNode(Opcodes.BASTORE))
            }
            return insnList
        }

        def encrypt = { String value, byte[] key, byte[] iv ->
            def cipher = javax.crypto.Cipher.getInstance("AES/GCM/NoPadding")
            def keySpec = new javax.crypto.spec.SecretKeySpec(key, "AES")
            def gcmSpec = new javax.crypto.spec.GCMParameterSpec(128, iv)
            cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, keySpec, gcmSpec)
            return cipher.doFinal(value.getBytes("UTF-8"))
        }

        def ensureClinit = { ClassNode cn ->
            MethodNode clinit = cn.methods.find { it.name == "<clinit>" && it.desc == "()V" }
            if (clinit != null) {
                return clinit
            }
            clinit = new MethodNode(Opcodes.ACC_STATIC, "<clinit>", "()V", null, null)
            clinit.instructions.add(new InsnNode(Opcodes.RETURN))
            cn.methods.add(clinit)
            return clinit
        }

        def secureRandom = new java.security.SecureRandom()
        int classCount = 0
        int stringCount = 0
        fileTree(encryptedClassesDir).matching { include "**/*.class" }.each { File classFile ->
            byte[] original = classFile.bytes
            ClassReader cr = new ClassReader(original)
            ClassNode cn = new ClassNode()
            cr.accept(cn, ClassReader.EXPAND_FRAMES)

            if (excludeClasses.contains(cn.name)) {
                return
            }
            boolean classEncrypt = shouldEncryptClass(cn)
            if (!classEncrypt && includeAnnDesc.isEmpty()) {
                return
            }

            boolean changed = false
            MethodNode clinit = null
            cn.fields.each { FieldNode fn ->
                if (!shouldEncryptField(fn, classEncrypt)) {
                    return
                }
                if ((fn.access & Opcodes.ACC_STATIC) == 0) {
                    return
                }
                if (fn.value instanceof String && "Ljava/lang/String;".equals(fn.desc)) {
                    String text = (String) fn.value
                    if (text != null && !text.isEmpty()) {
                        byte[] iv = new byte[12]
                        secureRandom.nextBytes(iv)
                        byte[] encrypted = encrypt(text, keyBytes, iv)

                        InsnList repl = new InsnList()
                        repl.add(buildByteArray(encrypted))
                        repl.add(buildByteArray(iv))
                        repl.add(new MethodInsnNode(
                                Opcodes.INVOKESTATIC,
                                "cn/lacknb/blog/llm/stream/StringDecryptor",
                                "d",
                                "([B[B)Ljava/lang/String;",
                                false
                        ))
                        repl.add(new org.objectweb.asm.tree.FieldInsnNode(
                                Opcodes.PUTSTATIC,
                                cn.name,
                                fn.name,
                                fn.desc
                        ))

                        if (clinit == null) {
                            clinit = ensureClinit(cn)
                        }
                        AbstractInsnNode last = clinit.instructions.getLast()
                        if (last != null && last.getOpcode() == Opcodes.RETURN) {
                            clinit.instructions.insertBefore(last, repl)
                        } else {
                            clinit.instructions.add(repl)
                        }

                        fn.value = null
                        changed = true
                        stringCount++
                    }
                }
            }

            cn.methods.each { MethodNode mn ->
                if (!shouldEncryptMethod(mn, classEncrypt)) {
                    return
                }
                AbstractInsnNode insn = mn.instructions?.first
                while (insn != null) {
                    AbstractInsnNode next = insn.next
                    if (insn instanceof LdcInsnNode && insn.cst instanceof String) {
                        String text = (String) insn.cst
                        if (text != null && !text.isEmpty()) {
                            byte[] iv = new byte[12]
                            secureRandom.nextBytes(iv)
                            byte[] encrypted = encrypt(text, keyBytes, iv)
                            InsnList repl = new InsnList()
                            repl.add(buildByteArray(encrypted))
                            repl.add(buildByteArray(iv))
                            repl.add(new MethodInsnNode(
                                    Opcodes.INVOKESTATIC,
                                    "cn/lacknb/blog/llm/stream/StringDecryptor",
                                    "d",
                                    "([B[B)Ljava/lang/String;",
                                    false
                            ))
                            mn.instructions.insert(insn, repl)
                            mn.instructions.remove(insn)
                            changed = true
                            stringCount++
                        }
                    }
                    insn = next
                }
            }

            if (changed) {
                ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS) {
                    @Override
                    protected String getCommonSuperClass(String type1, String type2) {
                        return "java/lang/Object"
                    }
                }
                cn.accept(cw)
                classFile.bytes = cw.toByteArray()
                classCount++
            }
        }
        println "String encryption done. classes=${classCount}, strings=${stringCount}"
    }
}

tasks.register('encryptedJar', Jar) {
    dependsOn(tasks.named('encryptStrings'))
    archiveClassifier.set("encrypted")
    from(encryptedClassesDir)
}
// 引入类
import org.objectweb.asm.ClassReader
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.Opcodes
import org.objectweb.asm.tree.AbstractInsnNode
import org.objectweb.asm.tree.ClassNode
import org.objectweb.asm.tree.InsnList
import org.objectweb.asm.tree.InsnNode
import org.objectweb.asm.tree.IntInsnNode
import org.objectweb.asm.tree.LdcInsnNode
import org.objectweb.asm.tree.MethodInsnNode
import org.objectweb.asm.tree.MethodNode
import org.objectweb.asm.tree.FieldNode
import proguard.gradle.ProGuardTask

tasks.register('obfuscateJar', ProGuardTask) {
//    dependsOn instrumentedJar
    dependsOn tasks.named('encryptedJar')

    // 插件不需要这一堆 args，直接调方法配置
    configuration 'proguard-rules.pro'

//    injars instrumentedJar.archiveFile
    injars tasks.named('encryptedJar').flatMap { it.archiveFile }
    outjars "$buildDir/obfuscated/${project.name}-obf.jar"

    // 插件会自动处理这几百个 jar，不会截断
    libraryjars sourceSets.main.compileClasspath

    // 补上 JDK 环境
    if (System.getProperty('java.version').startsWith('1.')) {
        libraryjars "${System.getProperty('java.home')}/lib/rt.jar"
    } else {
        libraryjars "${System.getProperty('java.home')}/jmods/java.base.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        libraryjars "${System.getProperty('java.home')}/jmods/java.desktop.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
    }

    doFirst {
        def javaHome = System.getProperty('java.home')

        // 1. 基础模块 (必须)
        libraryjars "${javaHome}/jmods/java.base.jmod", jarfilter: '!**.jar', filter: '!module-info.class'

        // 2. UI 模块 (解决 java.awt.*, javax.swing.*)
        libraryjars "${javaHome}/jmods/java.desktop.jmod", jarfilter: '!**.jar', filter: '!module-info.class'

        // 3. 【本次修复关键】HTTP 模块 (解决 java.net.http.HttpClient)
        // 如果你的文件不存在，请检查你的 JDK 版本是否 >= 11
        if (file("${javaHome}/jmods/java.net.http.jmod").exists()) {
            libraryjars "${javaHome}/jmods/java.net.http.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        }

        // 4. 【本次修复关键】数据传输模块 (解决 java.awt.datatransfer.Clipboard)
        // Clipboard 类其实是在 java.datatransfer 模块中定义的
        if (file("${javaHome}/jmods/java.datatransfer.jmod").exists()) {
            libraryjars "${javaHome}/jmods/java.datatransfer.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        }

        // 5. XML 解析 (解决 org.w3c.dom.* 等警告，插件开发常用)
        if (file("${javaHome}/jmods/java.xml.jmod").exists()) {
            libraryjars "${javaHome}/jmods/java.xml.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        }

        // 6. 日志与管理 (可选，视警告情况而定)
        if (file("${javaHome}/jmods/java.logging.jmod").exists()) {
            libraryjars "${javaHome}/jmods/java.logging.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        }

        // 7. 打印当前的 JDK 路径，方便调试确认用了哪个 JDK
        println "ProGuard using JDK libs from: ${javaHome}"
    }
}

test {
    useJUnitPlatform()
}
